---
id: http-stateful-stateless
title: Stateful 과 Stateless 의 차이
authors: irostub
tags: [irostub,2021,http,stateless,stateful]
keywords: [http,stateless,stateful]
last_update:
    date: 1/26/2023
    author: irostub
---
<head>
  <link rel="canonical" href="https://blog.nirohack.xyz/post/2021/0626-http-stateful-stateless/" />
</head>
# Stateful 과 Stateless 의 차이

HTTP 엔 여러 특징이 있는데 그 중 중요한 특징으로 **무상태(Stateless)** 가 있다. 
이 무상태라는 특징은 무엇인가? 그리고 무상태 특징을 왜 사용하는가? 에 대해서 알아보도록 합시다.

## 요약
:::info 세 줄 요약
무상태(Stateless) - 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존하지 않음을 의미합니다.

- 장점 : 서버의 확장성이 높기 때문에 대량의 트래픽 발생 시에도 대처를 수월하게 할 수 있습니다.
- 단점 : 클라이언트의 요청에 상대적으로 Stateful 보다 더 많은 데이터가 소모됩니다.
:::
## 상태 유지? 무상태?

**무상태** 단어 그대로 생각해보면 **"상태가 없는 것"** 이다. 그 반대의 경우 **"상태가 있는 것"** 이라 
생각할 수 있으며 이는 **상태 유지(stateful)** 라 한다. 무상태를 이해하기 위해 우선 상태가 있는 경우를 먼저 살펴보도록 합시다.


### 상태 유지

상태 유지라 함은 클라이언트와 서버 관계에서 서버가 클라이언트의 상태를 보존함을 의미합니다. 단순히 말하면 클라이언트의 이전 요청이 서버에 전달되었을 때, 
클라이언트의 다음 요청이 이전 요청과 관계가 이어지는 것을 의미합니다. 단순히 말하자곤 했지만, 
사실 이렇게 봐도 무슨 말인지 이해하기 힘듭니다. 역시 실제 사례를 바탕으로 이해하는 것이 빠를 것 같습니다. 예시를 봅시다.

- 자전거 판매를 하는 서버 X
- 자전거 사려는 클라이언트 A

서버와 클라이언트가 다음과 같이 준비되어있고 클라이언트가 자전거를 사기위해 클라이언트가 서버에게 자전거 부품을 단계별로 커스텀하여 요청을 하는 상황입니다. 
서로간의 대화는 다음과 같이 진행됩니다.

---

A : 자전거 사려합니다  
X : 자전거 커스텀 재료를 골라주세요 **(자전거를 사려한다는 것을 기억한다)**
  
  
A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요  
X : 배송은 어디로 해드릴까요? **(자전거를 사려했다는 것을 기억하고 있다)**
  
  
A : 집으로 보내주세요  
X : 결제는 무엇으로 해드릴까요? **(자전거를 사려했다는 것, 커스텀을 어떻게 했는지 알고 있다)**
  
  
A : 카드로 결제할게요  
X : 결제 완료 되었습니다. **(위의 모든 사용자가 요구했던 사항을 기억하고 있다)**

---

대화를 보면 판매하는 X 서버는 사용자의 이전 요청을 모두 기억하며 진행한다는 것을 알 수 있습니다. 이것이 상태 유지이며 지극히 정상적인 대화 처럼 보입니다. 
하지만 여기엔 ***함정***이 있습니다. 바로 판매하는 서버 X 가 바뀔 경우입니다. 만약 대량의 트래픽이 몰려들어서 서버를 긴급하게 늘렸다고 생각해봅시다. 
그러면 판매자 서버 X 가 아닌 증가된 어떤 서버 Y 가 될 수도 있습니다. 현실에서도 마트에서 너무 바쁘면 담당자가 바뀌기도 하는 것과 비슷합니다.  

다음은 X가 바뀌었을 경우의 상황입니다. 어떻게 될까요?

---

A : 자전거 사려합니다  
X : 자전거 커스텀 재료를 골라주세요
  
  
A : 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요  
Y : 네? 어떤걸 말씀하시는거죠?
  
  
A : 집으로 보내주세요  
Z : ?
  
  
A : 카드로 결제할게요  
X : 네?

---

말이 통하지 않습니다. 이게 바로 상태 유지의 문제입니다. 이러한 문제를 해결하기 위해 무상태가 등장하게됩니다.

### 무상태

상태 유지를 이해했다면 무상태는 생각보다 쉽게 이해할 수 있습니다. 바로 무상태의 예를 보도록합시다. 방금 전과 같은 상황을 가정합니다.

- 자전거 판매를 하는 서버 X, 대체 가능한 서버 Y, Z
- 자전거 사려는 클라이언트 A

---

A : 자전거 사려합니다.  
X : 자전거 커스텀 재료를 골라주세요. **(서버는 아무것도 기억하지 않는다)**

A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요.  
Y : 배송은 어디로 해드릴까요? **(서버는 아무것도 기억하지 않는다)**

A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요.  
Z : 결제는 무엇으로 해드릴까요? **(서버는 아무것도 기억하지 않는다)**

A : 자전거를 사려합니다. 휠은 검정색, 핸들은 검정색, 바디는 흰색, 안장은 흰색으로 해주세요. 배송은 집으로 보내주세요. 결제는 카드로 할게요.  
Y : 결제 완료 되었습니다. **(서버는 들어온 요청을 처리한다)**

---

무상태의 상황을 잘 보여주는 대화입니다. 이전의 클라이언트의 요청(상태)을 유지하지 않는 서버. 그것이 핵심입니다. 
무상태는 기존의 서버가 혼잡해져서 `새로운 서버를 가져다 놓아도` 기존의 비즈니스 로직을 그대로 구현하고
있다면 이전의 사용자 요청이 어떤지에 `관계없이 계속 일을 처리할 수 있습니다`. 
단, 단점은 클라이언트가 하고자하는 최종 목적을 위해 지나는 과정마다 점점 전달해야하는 내용이 많아진다는 것입니다.

대표적으로 많이 사용되는 약속 중 HTTP 는 이 무상태를 특징으로 기본적으로 가지고 있습니다. 
특별한 일이 없다면 무상태를 지향해야하며 필요한 경우에만 상태 유지를 해야합니다.
